
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Overview of API Design}
\label{sec::overview}

The pieces of the graph of the discrete space are represented by the
classes {\tt VolIndex} and {\tt FaceIndex}.   {\tt VolIndex} is an
abstract index into cell-centered locations corresponding to the nodes
of the graph (VoFs).   {\tt FaceIndex} is an abstract index into
edge-centered locations (locations between VoFs). The class {\tt
EBIndexSpace} is a container for geometric information at all levels
of refinement. The class {\tt EBISLevel} contains the geometric
information for a given level of refinement.  {\tt EBISLevel} is not
part of the public API and is considered internal to {\tt
EBIndexSpace}.  {\tt EBISBox} represents the intersection between an
{\tt EBISLevel} and a {\tt Box} and is used for aggregate access of
geometric information.   {\tt EBISLayout} is a set of {\tt EBISBox}es
corresponding to the boxes in a {\tt DisjointBoxLayout} grown by a
specified number of ghost cells. 

\begin{table}
\begin{center}
\begin{tabular}{|c||c|c|} 
\hline
Concept & Chombo & EBChombo 
\\ \hline\hline
$Z^D$             &  ----   & EBIndexSpace
\\
point in $Z^D$    & IntVect & VoF 
\\
region over $Z^D$ & Box     & EBISBox
\\
Union of Rectangles in $Z^D$ & BoxLayout     & EBISLayout
\\
data over region $Z^D$ & BaseFab & BaseEBCellFAB, BaseEBFaceFAB
\\ 
iterator over points & BoxIterator & VoFIterator, FaceIterator
\\ 
\hline                                                 
\end{tabular}
\end{center}
\caption{The concepts represented in Chombo and EBChombo.}
\label{fig::concepts}
\end{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Data Structures for Graph Representation}
\label{sec::graph}
The class {\tt VolIndex} is an abstract index into cell-centered locations
corresponding to the nodes of the graph.  
The class {\tt FaceIndex} is an abstract index into edge-centered locations
(locations between VoFs).
It is characterized by the pair of {\tt VolIndex}es that are connected by the
{\tt FaceIndex}. The possible range of values that can be taken on
by a {\tt VolIndex} or a {\tt FaceIndex} is determined by the index space 
containing the {\tt VolIndex}. {\tt FaceIndex}es always live at cell faces 
(there can be no {\tt FaceIndex} interior to a cell).
The entire graph is represented in the class {\tt EBIndexSpace}.
It stores all the connectivity of the graph and other
geometric information (volume fractions, area fractions, etc).
{\tt EBISBox} represents a subset of the {\tt EBIndexSpace} at a
particular refinement and over a particular box in the space.
{\tt EBISLayout} is a collection of {\tt EBISBox}es distributed
over processors associated with an input {\tt DisjointBoxLayout}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Class {\tt EBIndexSpace}}
\label{sec::EBIndexSpace}

The entire graph description of the geometry
is represented in the class {\tt EBIndexSpace}.
It stores all the connectivity of the graph and other
geometric information (volume fractions, area fractions, etc).
The important member functions of 
{\tt EBIndexSpace} are as follows.
\begin{itemize}
\item \begin{verbatim}
void define(const Box& BoundingBox,
            const RealVect& origin,
            const Real& dx,
            const GeometryService& geometry,
            int ncellmax, int nmaxcoarsen);
\end{verbatim}
Define data sizes. 
{\tt BoundingBox} is the {\tt Box} which defines the domain of the
EBIndexSpace at its finest resolution.
The arguments {\tt origin} and {\tt dx} specify
the location of the lower-left corner of the domain
and the grid spacing in each coordinate direction at the finest
resolution. The {\tt geometry} argument is the service class 
which tells the {\tt EBIndexSpace} how to build 
itself.  See section \ref{sec::geometryservice} 
for a description of the {\tt GeometryService} interface class.
Coarser resolutions of the EBIndexSpace are also generated in the
initialization process. {\tt ncellmax} is the maximum box size in the
database.  A smaller box size means that the the EBIndexSpace will be
able to distribute its data among more processors. {\tt nmaxcoarsen}
says now many coarsenings will be represented.   If either of these
integers is -1, a reasonable default box size and full coarsening are set.

\item \begin{verbatim}
void fillEBISLayout(EBISLayout& ebisLayout,
                    const DisjointBoxLayout& dbl,
                    const Box& domain,
                    const int& nGhost);
\end{verbatim}
Define an {\tt EBISLayout} for each box in the input layout
grown by the input ghost cells.  The input domain defines
the refinement level at which the layout exists.
The argument \verb/dbl/  is the layout over which the data is
distributed.  If every box does not lie within the input domain,   
a runtime error occurs. The \verb/domain/ argument is the 
problem domain at the refinement of the layout. 
If the refinement does not  exist within the {\tt EBIndexSpace}, 
a runtime error occurs.  The \verb/nghost/  argument defines 
the number of ghost cells in each coordinate direction.

\item \begin{verbatim}
int numLevels() const;
\end{verbatim}
Return the number of levels of refinement represented
in the {\tt EBIndexSpace}

\item \begin{verbatim}
int getLevel(const Box& a_domain) const;
\end{verbatim}
Return level index of domain.
Return -1 if \verb/a_domain/ does not
correspond to any refinement of the {\tt EBIndexSpace}.
\end{itemize}

{\tt EBIndexSpace} can only be accessed through the the
\verb/Chombo_EBIS/ singleton class.  The usage pattern
follows this model.  At some point, one defines the
{\tt GeometryService} object one wants to use (in
the example we use a SlabService) and defines
the singleton  as follows:
\begin{verbatim}
  SlabService slab(coveredBox);
  EBIndexSpace* ebisPtr = Chombo_EBIS::instance();
  ebisPtr->define(domain, origin, dx, slab);
\end{verbatim}
Whenever one needs to define an {\tt EBISLayout}, the usage
is as follows:
\begin{verbatim}
void makeEBISL(EBISLayout& a_ebisl, 
               const DisjointBoxLayout& a_grids, 
               const Box& a_domain, 
               const int& a_nghost)
{
  const EBIndexSpace* const ebisPtr = Chombo_EBIS::instance();
  assert(ebisPtr->isDefined());
  ebisPtr->fillEBISLayout(a_ebisl, a_grids, a_domain, a_nghost);
}
\end{verbatim}

\subsection{Class {\tt GeometryService}}
\label{sec::geometryservice}

The {\tt GeometryService} class defines an interface 
that {\tt EBIndexSpace} uses for geometry generation.
{\tt EBIndexSpace} builds an adaptive hierarchy of its
geometry information.  It queries the input {\tt GeometryService} 
with a two pass algorithm.  First EBIndexSpace resolves
which regions of the space are wholly regular, which are wholly
covered, and which contain irregular cells.  Then {\tt EBIndexSpace}
loops through the regions which contain irregular cells and
sends these regions (in the {\tt EBISBox} form to the 
{\tt GeometryService} to be filled.
The interface of {\tt GeometryService} is
\begin{itemize}
\item 
\begin{verbatim}
virtual bool isRegular(const Box& region, const Box& domain,
                       const RealVect& origin, const Real& dx)=0;
virtual bool isCovered(const Box& region, const Box& domain,
                       const RealVect& origin, const Real& dx)=0;
\end{verbatim}
Return true if {\em every} cell in the input region
is regular or covered.  
Argument {\tt region} is the subset of the domain.
The {\tt domain} argument specifies the span of the solution
index space.  The {\tt origin} argument specifies the location of the
lower-left corner (the zero node)
of the solution domain and the {\tt dx} argument 
specifies the grid spacing.
\item
\begin{verbatim}
virtual void fillEBISBox(EBISBox& ebisRegion, 
                         const Box& region,
                         const Box& domain,
                         const RealVect& origin, 
                         const Real& dx)=0;
\end{verbatim}
Fill the geometry of {\tt ebisRegion}.  
The {\tt region} argument specifies the subset of the domain
over which the {\tt EBISBox} will live.
The {\tt domain} argument specifies the span of the solution
index space.  The {\tt origin} argument specifies the location of the
lower-left corner (the zero node)
of the solution domain and the {\tt dx} argument 
specifies the grid spacing.   {\tt EBIndexSpace} checks that 
{\tt ebisRegion} covers the {\tt region} on output.
In this function,  the GeometryService must 
correctly fill all of the internal data in the 
{\tt EBISBox} class (we enumerate this data in section
\ref{sec::ebisbox}.  This function is only called if 
{\tt isRegular} and {\tt isCovered} return false for 
the input region.  The steps  for filling this data are as follows:
\begin{itemize}
 \item Set \verb/ebisRegion.m_type=EBISBoxImplem::HasIrregular/.
 \item Set \verb/ebisRegion.m_box=region/.
 \item Resize and set \verb/ebisRegion.m_typeID/.  On covered cells
        you set this to -2, on regular cells, you set it to -1
        and on irregular cells you set it to 0 or higher,
        corresponding to the cell's index into
        \verb/ebisRegion.irregVols/.
 \item Set the volumes in \verb/ebisRegion.m_irregVols/.  At each 
        cell, create a vector of volumes whose length is the
        number of VoFs in the cell.  
The internal class {\tt Volume} contains all
the auxiliary VoF information which is not absolutely
necessary for indexing.  For each {\tt Volume vol}
the {\tt GeometryService} must set 
\begin{itemize}
  \item \verb/vol.m_index/, the {\tt VolIndex} of the volume.
  \item \verb/m_volFrac/, the volume fraction of the volume.
  \item \verb/m_loFaces/, the low faces of the volume in each direction.
  \item \verb/m_hiFaces/, the high faces of the volume in each direction.
  \item \verb/m_loAreaFrac/, the low area fractions 
        of the volume in each direction.
  \item \verb/m_hiAreaFrac/, the high area fractions 
        of the volume in each direction.
\end{itemize}
\end{itemize}
\end{itemize}
For a {\tt GeometryService} to fill an {\tt EBISBox}, it must 
extract the internal data of the {\tt EBISBox} and fill it.
The internal data of {\tt EBISBox} is described in
section \ref{sec::ebisbox}.

{\tt GeometryService} is a friend class to {\tt EBISBox} 
and has access to its internal data.
Not all compilers respect that classes which derive from
friend classes are also friends.
Therefore the internal data should be accessed through these
{\tt GeometryService} functions which are designed to get
around this compiler feature:
\begin{itemize}
\item
\begin{verbatim}
  Box& getEBISBoxRegion(EBISBox& a_ebisBox) const
\end{verbatim}
This returns a reference to the region that the {\tt EBISBox} covers.
This needs to be set in all cases.

\item
\begin{verbatim}
  EBISBoxImplem::TAG& getEBISBoxEnum(EBISBox& a_ebisBox) const
\end{verbatim}
This returns a reference to the tag that marks whether the 
{\tt EBISBox} is all regular, all covered, or has irregular cells.
This needs to be set in all cases.

\item
\begin{verbatim}
  Vector<Vector<Vol> >& getEBISBoxIrregVols(EBISBox& a_ebisBox) const
\end{verbatim}
This returns the list of irregular VoF representations.  
This must only be filled if the this {\tt EBISBox} is tagged to have
irregular cells.

\item
\begin{verbatim}
  BaseFab<int>& getEBISBoxTypeID(EBISBox& a_ebisBox) const
\end{verbatim}
Return the flags for each cell in the {\tt EBISBox}.
This must only be filled if the this {\tt EBISBox} is tagged to have
irregular cells.
In this case, covered cells are to be tagged with -2, regular
cells are to be tagged  with  -1 and irregular VoFs are tagged
with the index into the vector of irregular volumes which corresponds
to this particular VoF.

\item
\begin{verbatim}
  IntVectSet& getEBISBoxMultiCells(EBISBox& a_ebisBox) const
\end{verbatim}
Returns a reference to the multiply-valued cells in the {\tt EBISBox}.
This must only be filled if the this {\tt EBISBox} is tagged to have
irregular cells.

\item
\begin{verbatim}
  IntVectSet& getEBISBoxIrregCells(EBISBox& a_ebisBox) const
\end{verbatim}
Return a reference to the set of irregular cells in the {\tt EBISBox}.
This must only be filled if the this {\tt EBISBox} is tagged to have
irregular cells.
\end{itemize}
An example of a {\tt GeometryService} class is given in 
section \ref{sec::slab}.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Class {\tt EBISBox}}
\label{sec::ebisbox}

{\tt EBISBox} represents the geometric information
of the domain at a given refinement 
within the boundaries of a particular box.
{\tt EBISBox} can only be accessed by using the
the {\tt EBISLayout} interface.  
EBISBox has as member data
\begin{small}
\begin{verbatim}
class EBISBox{
...
protected:
  Tag m_type;            //all reg, all covered, or has irregular
  BaseFab<int> m_typeID; //-2 covered,-1 regular, 0 or higher irreg
  Box m_box;             //region
  Vector< Vector< Volume > > irregVols;  
\end{verbatim}
\end{small}
where the internal class {\tt Volume} contains all
the auxiliary VoF information which is not absolutely
necessary for indexing. {\tt Volume} has the form
\begin{small}
\begin{verbatim}
struct Vol
{
  //this stuff gets filled in the finest level
  //by geometry service
  VolIndex m_index;
  Real m_volFrac;
  Tuple<Vector<FaceIndex>, SpaceDim> m_loFaces;
  Tuple<Vector<FaceIndex>, SpaceDim> m_hiFaces;
  Tuple<Vector<Real>, SpaceDim> m_loAreaFrac;
  Tuple<Vector<Real>, SpaceDim> m_hiAreaFrac;

  //this stuff gets managed by ebindexspace
  Vector<VolIndex> m_finerVoFs;
  VolIndex  m_coarserVoF;
};
\end{verbatim}
\end{small}
The integers stored in \verb/m_typeid/ double as the indices into
the the vectors of VoF information.  
The important public
member functions of {\tt EBISBox} are as follows:
\begin{itemize}
\item \begin{verbatim}
IntVectSet getMultiCells(const Box& subbox) const;
\end{verbatim}
Returns a list all multi-valued cells at the given level of refinement
within the input {\tt Box subbox}.

\item \begin{verbatim}
IntVectSet getIrregIVS(const Box& boxin) const;
\end{verbatim}
Returns the irregular cells of the {\tt EBISBox} that are 
within the input subbox.

\item \begin{verbatim}
Vector<VolIndex> getVoFs(const IntVect& iv);
\end{verbatim}
Gets all the VoFs in  a particular cell.

\item \begin{verbatim}
int numVoFs(const IntVect& iv) const;
\end{verbatim}
Returns the number of VoFs in a particular cell.

\item \begin{verbatim}
Vector<FaceIndex> getFaces(const VolIndex& vof, 
                           int idir, Side::LoHiSide sd);
\end{verbatim}
Gets all faces at the specified side and direction of the VoF.

\item \begin{verbatim}
bool isRegular(const IntVect& iv) const;
\end{verbatim}
Returns true if the input cell is a regular VoF.

\item \begin{verbatim}
bool isRegular(const Box& box) const;
\end{verbatim}
Returns true if every cell in the input Box is a regular VoF.

\item \begin{verbatim}
bool isCovered(const IntVect& iv) const; 
\end{verbatim}
Returns true if the input cell is a covered cell.

\item \begin{verbatim}
bool isCovered(const Box& box) const; 
\end{verbatim}
Returns true if every cell in the input box is a covered cell.

\item \begin{verbatim}
bool isIrregular(const IntVect& iv) const;
\end{verbatim}
Returns true if the input cell is an irregular cell. 

\item \begin{verbatim}
int numFaces(const VolIndex& vofin, 
        int dir, Side::LoHiSide sd) const;
\end{verbatim}
Returns the number of faces the input VoF has 
in the given direction and side.  Returns zero if
the VoF has no faces in the given orientation.

\item \begin{verbatim}
Real volFrac(const VolIndex& vofin) const;
\end{verbatim}
Returns the volume fraction of the input VoF.


\item\begin{verbatim}
bool isConnected(const VolIndex& vof1,
                 const VolIndex& vof2) const;
\end{verbatim}
Return true if the two input VoFs are connected by a face.

\item\begin{verbatim}
bool isAllCovered();
\end{verbatim}
Return true if every cell in the {\tt EBISBox} is covered.

\item\begin{verbatim}
bool isAllRegular();
\end{verbatim}
Return true if every cell in the {\tt EBISBox} is regular.

\item\begin{verbatim}
RealVect normal(const VolIndex& vofin) const;
\end{verbatim}
Returns the normal to the body at the input VoF. Return the zero
vector if the answer is undefined (for example,
if the VoF is regular or covered).

\item\begin{verbatim}
RealVect centroid(const VolIndex& vofin) const;
\end{verbatim}
Returns the centroid of the VoF.  Returns the zero vector if the VoF
is regular or covered.  The answer is given as a normalized (by grid
spacing) offset from the center of the cell (all numbers range from
-0.5 to 0.5). 

\item \begin{verbatim} 
RealVect  centroid(const FaceIndex& facein) const;
\end{verbatim} 
Return centroid of input  face as a RealVect whose component in
the uninteresting direction normal to  the face is undefined. In the
(one or two) interesting directions returns  the centroid of the input
VoF. Return the zero vector if  the face is covered or regular.  The
answer is given as a normalized (by grid spacing) offset from the
center of the cell face (all numbers range from -0.5 to 0.5).

\item \begin{verbatim}
Real areaFrac(const FaceIndex& a_vof1);
\end{verbatim}
Return the area fraction of the face.
Returns zero if the two VoFs in the face
are not actually connected.

\item \begin{verbatim}
Vector<VolIndex> refine(const VolIndex& coarseVoF) const;
\end{verbatim}
Returns the corresponding set of VoFs from the next finer
{\tt EBISLevel} (factor of two refinement).  The result is only
defined if this {\tt EBISBox} was defined by coarsening.  

\item\begin{verbatim}
VolIndex coarsen(const VolIndex& vofin);
\end{verbatim}
Returns the corresponding  VoF from the next coarser 
{\tt EBISLevel} (same solution location, different index space, factor
of two refinement ratio).


\item \begin{verbatim}
void copy(const Box&     a_regionFrom, const Interval& Cd, 
          const Box&     a_regionTo,
          const EBISBox& a_source, const Interval& Cs);
\end{verbatim}
Copy the information from \verb/a_source/ over 
box \verb/a_regionFrom/, to the \verb/a_regionTo/ box of the current
{\tt EBISBox}.  The interval arguments are ignored.   
This function is required by the {\tt LevelData} template class.
\end{itemize}
{\tt GeometryService} is a friend class to {\tt EBISBox}
so it can manipulate the internal data of {\tt EBISBox}
to create the geometric description.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Class {\tt EBISLayout}}
\label{sec::ebislayout}

{\tt EBISLayout} is a collection of {\tt EBISBox}es distributed
across processors and associated with a {\tt DisjointBoxLayout}
and a number of ghost cells.  In a parallel context,  {\tt EBISLayout}
is the way the user can create parallel, distributed data.  
{\tt EBISLayouts} are null-constructed and are defined 
by sending them to the {\tt fillEBISLayout(...)}
function of {\tt EBIndexSpace}.  {\tt EBISLayout} is constructed around a 
reference-counted pointer of an {\tt EBISLayoutImplem}
object so copying {\tt EBISLayouts} is inexpensive and
follows the reference-counted pointer semantic (changing
the copied-to object changes the copied-from object).
Recall that one can coarsen and refine only by a factor of two
using the {\tt EBISBox} class directly.  Because {\tt EBISBox}
archives the information to do this, it is an inexpensive operation.
Coarsening and refinement using larger factors of refinement
must be done through {\tt EBISLayout} and it can be expensive,
especially in terms of memory usage.
When one sets the maximum levels of refinement and coarsening,
{\tt EBISLayout} creates mirrors of itself at all intermediate
levels of refinement and holds those new {\tt EBISLayout}s as
member data.  Refinement and coarsening is done by threading
through these intermediate levels.
The important functions of {\tt EBISLayout} follow.  
\begin{itemize}
\item \begin{verbatim}
const EBISBox& operator[] (const DataIndex& a_datInd) const;
\end{verbatim}
Access the {\tt EBISBox} associated with the input {\tt DataIndex}.
Only constant access is permitted.

\item \begin{verbatim}
void setMaxRefinementRatio(const int& a_maxRefine);
\end{verbatim}
Sets the maximum level of refinement that this {\tt EBISLayout}
will have to perform.  Creates and holds new {\tt EBISLayout}s
at intermediate levels of refinement.
Default is one (no refinement done).

\item \begin{verbatim}
setMaxCoarseningRatio(const int& a_maxCoarsen);
\end{verbatim}
Sets the maximum level of coarsening that this {\tt EBISLayout}
will have to perform.  Creates and holds new {\tt EBISLayout}s
at intermediate levels of coarsening.
Default is one (no coarsening done).

\item \begin{verbatim}
VolIndex coarsen(const VolIndex& a_vof,
                 const int& a_ratio,
                 const DataIndex& a_datInd) const;
\end{verbatim}
Returns the index of the VoF corresponding to coarsening
the input VoF by the input ratio.  It is an error if
the ratio is greater than the maximum coarsening ratio
or if the VoF does not exist at the input data index.

\item \begin{verbatim}
Vector<VolIndex> refine(const VolIndex& a_vof,
                        const int& a_ratio,
                        const DataIndex& a_datInd) const;
\end{verbatim}
Returns the indices of the VoFs corresponding to refining
the input VoF by the input ratio.  It is an error if
the ratio is greater than the maximum refinement ratio
or if the VoF does not exist at the input data index.


\item \begin{verbatim}
const BoxLayout& getLayout() const
\end{verbatim}
Return the ghosted layout that underlies the {\tt EBISLayout}
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Class {\tt VolIndex}}
\label{sec::volindex}

The class {\tt VolIndex} is an abstract index into cell-centered locations
which corresponds to the nodes of the computational graph.  
Every VoF has an associated volume fraction that can be
between zero and one.  A VoF with zero volume fraction has no 
volume inside the solution domain.  A VoF
with unity volume fraction has no covered region.
The types of VoF are listed below:
\begin{itemize}
\item Regular: VoF has unit volume fraction and
has exactly 2*D Faces, each of 
unit area fraction. 
\item Covered: VoF has zero volume fraction and no faces.
\item Irregular: Any other valid  VoF.   These are VoFs which
either intersect the embedded boundary or border a covered
cell.
\item Invalid: The VoF is incompletely defined.  The default when you create 
a  VoF, and used as the out-of-domain  VoF of a boundary Face.
\end{itemize}
Since we anticipate storing them in very large numbers,
we design the class {\tt VolIndex} to be a very small object
in terms of memory.   Its only member data is an 
{\tt IntVect} to identify its cell and an integer
identifier.  
\begin{small}
\begin{verbatim}
class VolIndex{
...
protected:
  IntVect m_cell; // which cell am i in
  int     m_ident;
\end{verbatim}
\end{small}
The integer identifier is used to find all the geometric 
information stored in its {\tt EBISBox}.
The class {\tt VolIndex} contains the following important member functions:
\begin{itemize}
\item {\verb/IntVect gridIndex() const/} 
Returns the {\tt IntVect} of the VoF.
\item {\verb/int cellIndex() const/} 
Returns the cell identifier of the VoF.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Class {\tt FaceIndex}}

The class {\tt FaceIndex} is an abstract index into locations centered
on the edges of the graph.  A {\tt FaceIndex} exists between two VoFs
and is defined by those VoFs.
Every {\tt FaceIndex} has an associated area fraction that can be
between zero and one.  A {\tt FaceIndex} with zero area fraction has no flow
area.  A {\tt FaceIndex} with unity area fraction has no covered area.
It should be noted that a {\tt FaceIndex}
knows whether it is a boundary face or an interior face
by which constructor was used to define it.  
Only friend classes 
({\tt EBISBox, GeometryService, EBIndexSpace...})
may call the defining constructors.  Only the null constructor
of {\tt FaceIndex} should be used by users.  
The internal data 
of the {\tt FaceIndex} class is as follows:
\begin{verbatim}
   int m_idir;
   bool m_isBoundary;
   int m_ivoflo;
   int m_ivofhi;
   IntVect m_ivhi;    
   IntVect m_ivlo;    
\end{verbatim}
The cell locations (the {\tt IntVect}s) can lie outside the domain
if the {\tt FaceIndex} is on the boundary of the domain.
The important member functions of this class are:
\begin{itemize}
\item \begin{verbatim} 
const IntVect& gridIndex(Side::LoHiSide sd) const
\end{verbatim} 
Return the cell of the {\tt VolIndex} on the {\tt sd}
side of the face.

\item \begin{verbatim} 
const int& cellIndex(Side::LoHiSide sd) const
\end{verbatim} 
Return the cell index of the {\tt VolIndex} on the {\tt sd}
side of the face.  Returns -1 if that {\tt VolIndex} is
outside the domain of computation.

\item \begin{verbatim} 
VolIndex getVoF(Side::LoHiSide sd) const
\end{verbatim} 
Get the VoF at the given side of the face.  Will return
a VoF with a negative cell index if the IntVect of that
VoF is outside the domain.
\item \begin{verbatim} 
int direction() const;
\end{verbatim} 
Returns direction of the face.
The direction of a {\tt FaceIndex} is the 
integer coordinate direction (0...D-1) whose
unit vector is normal to the face.
\item \begin{verbatim} 
bool isBoundary() const
\end{verbatim} 
Returns true if the face is on the boundary of the domain.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Data Holders for Embedded Boundary Applications}
\label{sec::ebdata}

A {\tt BaseIVFAB<T>} is an array of data defined in an irregular
region of space.  
The irregular region is specified by the {\tt VolIndex}s of an {\tt
IntVectSet}. 
Multiple data components per {\tt VolIndex} may be specified in the
{\tt BaseIVFAB} definition.

A {\tt BaseIFFAB<T>} is an array of data defined in an irregular
region of space. 
The irregular region is specified by the faces of an {\tt
IntVectSet}. All the faces in a {\tt BaseIFFAB} must 
have the same spatial orientation, which is
specified in the {\tt BaseIFFAB} definition.  Multiple data components per
face may be specified in the definition.
{\tt BaseEBCellFAB} is a templated
class which holds cell-centered 
data over a region which is described by a rectangular 
subset of an embedded boundary.  
{\tt BaseEBFaceFAB}  is a templated
class which holds face-centered data over a similar
region. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Class {\tt BaseIFFAB<T>}}
\label{sec::BaseIFFAB}

A {\tt BaseIFFAB<T>} is a templated 
array of data defined in an irregular region of space.
The irregular region is specified by the faces of an 
{\tt IntVectSet}.  All the faces in a
{\tt BaseIFFAB} must have the same spatial orientation, which is
specified in the {\tt BaseIFFAB} definition.  Multiple data components per
face may be specified in the definition.  The important functions of
{\tt BaseIFFAB} follow.   
\begin{itemize}
\item \begin{verbatim}
BaseIFFAB(const IntVectSet& iggeom_in, 
          const EBISBox& a_ebisBox,
          int dirin, int nvarin,
          bool interiorOnly=false);
\end{verbatim}
Defining constructor. The arguments specify the valid domain in the form of an
IntVectSet, the spatial orientation of the faces, and the number of
data components per face.  The contents are uninitialized.    
The  {\tt interiorOnly} argument specifies whether the data holder
will span either the surrounding faces of the set or the interior
faces of the set.

\item \begin{verbatim}
void setVal(T value);
\end{verbatim}
Set a value everywhere.  Every data location in this {\tt BaseIFFAB} is set.

\item \begin{verbatim}
void copy(const Box& a_intBox, const Interval& Cd, 
          const Box& a_toBox
          const BaseIFFAB<T>& a_source, const Interval& Cs);
\end{verbatim} 
Copy the contents of another BaseIFFAB into this BaseIFFAB over
the specified regions and intervals.

\item \begin{verbatim}
int nComp() const;
\end{verbatim}
Return the number of data components of this BaseIFFAB.

\item \begin{verbatim}
int direction() const;
\end{verbatim}
Return the direction of the faces of this BaseIFFAB.

\item \begin{verbatim}
T& operator() (const FaceIndex& edin, int varlocin);
\end{verbatim}
Indexing operator.  Return a reference to the contents of this BaseIFFAB,
at the specified face and data component.  The first component is
zero, the last is {\em nvar-1}.  The returned object is a modifiable
lvalue. 

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Class {\tt BaseIVFAB<T>}}
\label{sec::BaseIVFAB}

A {\tt BaseIVFAB<T>} is a templated
array of data defined in an irregular region of space.
The irregular region is specified by the {\tt VolIndex}s of an {\tt IntVectSet}.
Multiple data components per {\tt VolIndex} may be specified in the
{\tt BaseIVFAB} definition.  The important member functions of {\tt BaseIVFAB}
follow.
\begin{itemize}
\item \begin{verbatim} 
 BaseIVFAB(const IntVectSet& iggeom_in,               
           const EBISBox& a_ebisBox,
           int nvarin = 1);
\end{verbatim} 
Defining constructor.  Specifies the valid domain in the form of
an IntVectSet and the number of data components per VoF.  The
contents are uninitialized. 

\item \begin{verbatim}
void setVal(T value);
\end{verbatim}
Set a value everywhere.  Every data location in this {\tt BaseIVFAB} is
set to the input value.

\item \begin{verbatim}
void copy(const Box& a_fromBox, const Interval& destInterval,
          const Box& a_toBox,     
          const BaseIVFAB<T>& src, const Interval& srcInterval);
\end{verbatim}
Copy the contents of another {\tt BaseIVFAB} into this {\tt BaseIVFAB}.  
over the specified regions and intervals.

\item \begin{verbatim}
T& operator() (const VolIndex& ndin, int varlocin);
\end{verbatim}
Indexing operator.  Return a reference to the contents of this {\tt BaseIVFAB},
at the specified VoF and data component.  The first component is
zero, the last is {\em nvar-1}.  The returned object is a modifiable
lvalue.     

\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Class {\tt BaseEBCellFAB<T>}}
\label{sec::baseebcellfab}

A {\tt BaseEBCellFAB<T>} is a templated holder for cell-centered 
data over a region
which consists of the intersection
of a cell-centered box and an {\tt EBIndexSpace}.  At every uncovered VoF in this 
intersection, the {\tt BaseEBCellFAB} contains a specified number of
data values. 
At singly valued cells,
the data is stored internally in a \verb/BaseFab<T>/.  At multiply-valued
cells, the data is stored internally in a  {\tt BaseIVFAB}.
{\tt BaseEBCellFAB} provides indexing by VoF and access to the regular
data's pointer for passage to FORTRAN subroutines.
This class does not provide a copy constructor or assignment operator.  

The important functions for the class {\tt BaseEBCellFAB} is defined as follows.
\begin{itemize}
\item \begin{verbatim}
void define(const EBISBox a_ebis,const Box& a_region,int a_nVar);
\end{verbatim}
Full define function.  Defines the domain of the {\tt BaseEBCellFAB}
to be the intersection of the input {\tt Box} and the domain
of the input {\tt EBISBox}.   Creates the space for data at 
every VoF in this intersection.

\item \begin{verbatim}
void setVal(T a_value);
\end{verbatim}
Set the value of all data in the container to \verb/a_value/.

\item \begin{verbatim}
void copy(const Box& a_RegionFrom, const Interval& destInt,
          const Box& a_RegionTo,        
          const BaseEBCellFAB<T>& a_srcFab,
          const Interval& srcInt);         
\end{verbatim}
Copy the data from \verb/a_srcFab/ into the
current {\tt BaseEBCellFAB} regions and intervals specified.

\item \begin{verbatim}
T& operator()(const VolIndex& a_vof, int a_nVarLoc);
\end{verbatim}
Returns the data at VoF \verb/a_vof/ for variable number
\verb/a_nVarLoc/.  Returns a modifiable l value.

\item \begin{verbatim}
BaseFab<T>& getSingleValuedFAB();
\end{verbatim}
Returns the single-valued data holder.  This holds all data which is
single-valued (regular and irregular).  This is useful so
that the data can be passed to Fortran using the {\tt BaseFab} interface.

\item \begin{verbatim}
BaseIVFAB<T>& getMultiValuedFAB();
\end{verbatim}
Returns the multi-valued data holder. 

\item \begin{verbatim}
const IntVectSet& getMultiCells() const;
\end{verbatim}
Returns the {\tt IntVectSet}  of all the multiply-valued cells.

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Class {\tt EBCellFAB}}
\label{sec::ebcellfab}

An {\tt EBCellFAB} is a holder for cell-centered 
floating--point data over a region
which consists of the intersection
of a cell-centered box and an {\tt EBIndexSpace}.  It is 
an extension of a \verb/BaseEBCellFAB<Real>/ which includes
arithmetic functions.  
The data is stored internally in a \verb/FArrayBox/.  At multiply-valued
cells, the data is stored internally in a  {\verb/BaseIVFAB<Real>/}.
{\tt EBCellFAB} provides indexing by VoF and access to the regular
data's pointer for passage to FORTRAN subroutines.
This class does not provide a copy constructor or assignment operator.  
{\tt EBCellFAB} has all the functions of \verb/BaseEBCellFAB<Real>/
and the following extra functions:
\begin{itemize}

\item \begin{verbatim}
FArrayBox& getSingleValuedFAB();
\end{verbatim}
Returns the regular data holder.  This is useful so
that the data can be passed to Fortran using the {\tt BaseFab} interface.

\item \begin{verbatim}
EBCellFAB& operator+=(const Real& a_valin);
EBCellFAB& operator-=(const Real& a_valin);
EBCellFAB& operator*=(const Real& a_valin);
EBCellFAB& operator/=(const Real& a_valin);
\end{verbatim}
Add (or subtract or multiply or divide 
\verb/a_valin/ to (or from or by or into)  every data value in the holder.


\item \begin{verbatim}
EBCellFAB& operator+=(const EBCellFAB& a_fabin);
EBCellFAB& operator-=(const EBCellFAB& a_fabin);
EBCellFAB& operator*=(const EBCellFAB& a_fabin);
EBCellFAB& operator/=(const EBCellFAB& a_fabin);
\end{verbatim}
Add (or subtract or multiply or divide) the internal values 
to (or from or by or into) the values in {\verb/fabin/}
over the intersection of the domains of the two holders
and put the result in the current holder.
It is an error if the two holders do not contain the same number
of variables.

\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Class {\tt BaseEBFaceFAB<T>}}
\label{sec::baseebfacefab}

A {\tt BaseEBFaceFAB<T>} is a templated holder for face-centered 
data over a region
which consists of the intersection
of a cell-centered box and an {\tt EBIndexSpace}.  At every uncovered face in this 
intersection, the {\tt BaseEBFaceFAB} contains a specified number  of data
values.  At singly valued faces,
the data is stored internally in a \verb/BaseFab<T>/.  At multiply-valued
cells, the data is stored internally in a {\tt BaseIFFAB}.
{\tt BaseEBFaceFAB} provides indexing by face and access to the regular
data's pointer for passage to FORTRAN subroutines.
This class does not provide a copy constructor or assignment operator.  
The important functions for the class {\tt BaseEBFaceFAB} are defined as follows.
\begin{itemize}

\item \begin{verbatim}
void define(const EBISBox& a_ebis,
            const Box& a_region, int a_idir, int a_nVar,
            bool interiorOnly = false);
\end{verbatim}
Full define function.  Defines the domain of the {\tt BaseEBFaceFAB}
to be the intersection of the input {\tt Box} and the 
faces of the input {\tt EBISBox} in the given direction.   
Creates the space for data at every face in this intersection.
The  {\tt interiorOnly} argument specifies whether the data holder
will span either the surrounding faces of the set or the interior
faces of the set.

\item \begin{verbatim}
void setVal(T a_value);
\end{verbatim}
Set the value of all data in the container to \verb/a_value/.

\item\begin{verbatim}
T& operator()(const FaceIndex& a_face, int a_nVarLoc);
\end{verbatim}
Returns the data at face \verb/a_face/ for variable number
\verb/a_nVarLoc/.  Returns a modifiable l value.


\item \begin{verbatim}
void copy(const Box& a_RegionFrom, const Interval& a_destInt,
          const Box& a_RegionTo,
          const EBFaceFAB<T>& a_source,
          const Interval& a_srcInt);
\end{verbatim}
Copy the data from \verb/a_source/ into the
current {\tt BaseEBFaceFAB} over regions and intervals specified.

\item \begin{verbatim}
BaseFab<T>& getSingleValuedFAB();
\end{verbatim}
Returns the regular data holder.  This is useful so
that the data can be passed to Fortran 
using the {\tt BaseFab} interface.

\item \begin{verbatim}
const IntVectSet& getMultiCells() const;
\end{verbatim}
Returns the {\tt IntVectSet}  of all the multiply-valued cells.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Class {\tt EBFaceFAB}}
\label{sec::ebfacefab}

An {\tt EBFaceFAB} is a holder for face-centered 
floating-point data over a region
which consists of the intersection
of a face-centered box and an {\tt EBIndexSpace}.  It is 
an extension of a \verb/BaseEBFaceFAB<Real>/ which includes
arithmetic functions.  At single-valued cells, the data is stored
internally in a \verb/BaseFab<Real>/.  At multiply-valued 
faces, the data is stored internally in a  {\verb/BaseIFFAB<Real>/}.
{\tt EBFaceFAB} has all the functions of \verb/BaseEBFaceFAB<Real>/
and the following extra functions:
\begin{itemize}
\item \begin{verbatim}
FArrayBox& getSingleValuedFAB();
\end{verbatim}
Returns the regular data holder.  This is useful so
that the data can be passed to Fortran using the {\tt BaseFab}
interface.

\item \begin{verbatim}
EBFaceFAB& operator+=(const EBFaceFAB& fabin); 
EBFaceFAB& operator-=(const EBFaceFAB& fabin); 
EBFaceFAB& operator*=(const EBFaceFAB& fabin); 
EBFaceFAB& operator/=(const EBFaceFAB& fabin); 
\end{verbatim}
Add (or subtract or multiply or divide) 
the values in {\verb/a_fabin/} to (or from or by or into) 
the internal values
over the intersection of the domains of the two holders
and put the result in the current holder.
It is an error if the two holders do not contain the same number
of variables.
It is an error if the two holders have different face directions.

\item \begin{verbatim}
EBFaceFAB& operator+=(const Real& a_valin); 
EBFaceFAB& operator-=(const Real& a_valin); 
EBFaceFAB& operator*=(const Real& a_valin); 
EBFaceFAB& operator/=(const Real& a_valin); 
\end{verbatim}
Add (or subtract or multiply or divide) 
\verb/a_valin/ to (or from or by or into) every data value in the holder.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Data Structures for Pointwise Iteration}

EBChombo contains two classes which facilitate 
pointwise iteration, {\tt VoFIterator} and {\tt FaceIterator}. 
{\tt VoFIterator} is used to iterate over every point
in an {\tt IntVectSet}.  {\tt FaceIterator} iterates
over faces in an {\tt IntVectSet} in a particular direction.

\subsection{Class {\tt VoFIterator}}

VoFIterator iterates over every uncovered
VoF  in  an {\tt IntVectSet} inside an {\tt EBISBox}.
Its important functions are as follows
\begin{itemize}
\item \begin{verbatim}
  VoFIterator(const IntVectSet& a_ivs,
              const EBGraph& a_ebisBox);
  void define(const IntVectSet& a_ivs,
              const EBGraph& a_ebisBox);
\end{verbatim}
    Define the {\tt VoFIterator} with the input
    {\tt IntVectSet} and the {\tt EBISBox}.
    The {\tt IntVectSet} defines the points that
    will be iterated over and should be contained
    within the region of {\tt EBISBox}.  
    Calls {\tt reset()} after construction.

\item \begin{verbatim}
  void reset();
\end{verbatim}
  Rewind the iterator to its beginning.

\item \begin{verbatim}
  void operator++();
\end{verbatim}
 Advance the iterator to its next VoF.

\item \begin{verbatim}
  bool ok() const;
\end{verbatim}
Return true if there are more unvisited VoFs for
the iterator to cover.

\item \begin{verbatim}
  const VolIndex& operator() () const;
\end{verbatim}
Return the current VoF.
\end{itemize}
The following routine sets the 0th component of the
data holder to a constant value at each point in
the input set.
\begin{small}
\begin{verbatim}
/******************/
void setPhiToValue(EBCellFAB& a_phi,
                   const IntVectSet& a_ivs,
                   const EBISBox& a_ebisBox,
                   const Real& a_value)
{
   VoFIterator vofit(a_ivs, a_ebisBox.getEBGraph());
   for(vofit.reset(); vofit.ok(); ++vofit)
     {
        const VolIndex& vof = vofit();
        a_phi(vof, 0) = a_value;
     }
}
/******************/
\end{verbatim}
\end{small}
The call to {\tt reset()} in the above code
is unnecessary in this case.  One only needs
to call {\tt reset()} if an iterator is 
used multiple times.

\subsubsection{Performance Note}
{\tt VoFIterator} caches all its {\tt VolIndex}es
into a {\tt Vector} on construction.  In this 
way, {\tt VoFIterator} is
designed to be fast in  iteration but not
necessarily fast in construction.  If one
were to find {\tt VoFIterator} construction
to be a significant performance issue
in a class, one might consider caching the {\tt VoFIterator}s
one needs in the member data of said class.



\subsection{Class {\tt FaceIterator}}

The {\tt FaceIterator} class is used to iterate
over faces of a particular direction in an {\tt IntVectSet}.
First we must define {\tt FaceStop},
the enumeration class which distinguishes which faces
at which a given {\tt FaceIterator} will stop.  The entirety
of the {\tt FaceStop} class is given below.
\begin{small}
\begin{verbatim}
class FaceStop
{
public:
  enum WhichFaces{Invalid=-1, 
                  SurroundingWithBoundary=0, HiWithBoundary, LoWithBoundary, 
                  SurroundingNoBoundary    , HiNoBoundary  , LoNoBoundary, 
                  NUMTYPES};
};
\end{verbatim}
\end{small}
The enumeratives are described as follows:
\begin{itemize}
\item SurroundingWithBoundary  means stop at all faces on the high and
low sides of {\tt IntVectSet} cells.  
\item SurroundingNoBoundary  means stop at all faces on the high and
low sides of {\tt IntVectSet} cells, excluding faces on the domain boundary. 
\item LoWithBoundary  means stop at all faces on the      low side of
{\tt IntVectSet} cells. 
\item LoNoBoundary  means stop at all faces on the     low side of
{\tt IntVectSet} cells, excluding faces on the domain boundary. 
\item HiWithBoundary  means stop at all faces on the      high side of
{\tt IntVectSet} cells. 
\item HiNoBoundary  means stop at all faces on the     high side of
{\tt IntVectSet} cells, excluding faces on the domain boundary. 
\end{itemize}
Now we may define the important interface of {\tt FaceIterator}:
\begin{itemize}
\item \begin{verbatim}
 FaceIterator(const IntVectSet& a_ivs,
              const EBGraph& a_ebisBox,
              const int& a_direction,
              const FaceStop::WhichFaces& a_location);
  void define(const IntVectSet& a_ivs,
              const EBGraph& a_ebisBox,
              const int& a_direction,
              const FaceStop::WhichFaces& a_location);
\end{verbatim}
  Defining constructor.  

\item \begin{verbatim}
  void reset();
\end{verbatim}
  Rewind the iterator to its beginning.

\item \begin{verbatim}
  void operator++();
\end{verbatim}
 Advance the iterator to its next face.

\item \begin{verbatim}
  bool ok() const;
\end{verbatim}
Return true if there are more unvisited faces for
the iterator to cover.

\item \begin{verbatim}
  const FaceIndex& operator() () const;
\end{verbatim}
Return the current face.
\end{itemize}
The following routine sets the 0th component of the
data holder to a constant value at each face in
the input set, including boundary faces.
\begin{small}
\begin{verbatim}
/******************/
void setFacePhiToValue(EBFaceFAB& a_phi,
                       const IntVectSet& a_ivs,
                       const EBISBox& a_ebisBox,
                       const Real& a_value)
{
   int direction = a_phi.direction();
   FaceIterator faceit(a_ivs, a_ebisBox.getEBGraph(), direction,
                       FaceStop::SurroundingWithBoundary);
   for(faceit.reset(); faceit.ok(); ++faceit)
     {
        const FaceIndex& face = faceit();
        a_phi(face, 0) = a_value;
     }
}
/******************/
\end{verbatim}
\end{small}
The call to {\tt reset()} in the above code
is unnecessary in this case.  One only needs
to call {\tt reset()} if an iterator is 
used multiple times.

\subsubsection{Performance Note}
{\tt FaceIterator} caches all its {\tt FaceIndex}es
into a {\tt Vector} on construction.  
In this way, {\tt FaceIterator} is
designed to be fast in iteration but not
necessarily fast in construction.  If one
were to find {\tt FaceIterator} construction
to be a significant performance issue
in a class, one might consider caching the {\tt FaceIterator}s
one needs in the member data of said class.


\section{Input/Output}

\subsection{Design Considerations}

Goals of Input/Output API are:

\begin{itemize}
\item Binary portable files
\item Completeness:
    \begin{itemize}
    \item An EBChombo data file should contain sufficient information
    to reconstruct both the {\tt EBIndexSpace} object, as well as the 
    appropriate data type.  In our case we have broken these two functions
    into separate files.
    \end{itemize}
\item Efficiency.  An EBChombo data file should strive to be at least as space
efficient as the in-memory representation.
\end{itemize}

  As of this time HDF5 still does not support asynchronous DATASET or GROUP creation.
This means that to achieve parallel performance we still cannot move to a protocol
that maps each {\tt EBISBox} to an HDF5 DATASET. 


\subsection{HDF5 Data File Description}

EBChombo uses two independent files.  The first file is an output of
the {\tt EBIndexSpace} object (a {\em serialization}). It outputs the 
EBIndexSpace at it's finest resolution.  At the finest grid resolution there
are no grid cells that contain multiple control volumes.  This is called the {\tt EBFile}.
We will strive to consistently use the file extension {\tt .eb} for this file.

The second file is our {\tt EBData} file.  It handles EBChombo in a similar manner
to EBChombo:  regular array data over most of the domain, unstructured data
representation where the embedded boundary intersects the regular Cartesian. It is not
a complete geometry representation as it only stores geometric information at the
AMR level of refinement. We will use the file extension {\tt .ebd} for these files.

  VisIt can utilize the {\tt EBData} file.

  EBChombo can read and write both {\tt EBFile} and {\tt EBData} files.  On read
EBChombo only extracts the non-geometric data from an {\tt EBData} file. Geometric
information is sourced from the {\tt EBFile}.  A future optimization for EBChombo
I/O would be an option to turn off the writing of geometric information into the
{\tt EBData} file when VisIt will not be used, or when just regular cell visualization
is adequate.  This can wait until profiling.


\subsubsection{{\tt EBData} file }


  We introduce four new H5T compound data types: {\tt H5T\_VOF2D,  H5T\_VOF3D
H5T\_FACE2D, H5T\_FACE3D}:

\begin{verbatim}
 DATATYPE  H5T_COMPOUND H5T_VOF*D {
            H5T_REAL "volFrac";
            H5T_REAL "bndryArea";
            H5T_REALVECT "normal";
            H5T_REALVECT "centroid";
            H5T_INTVECT "cell"; 
 }

 DATATYPE  H5T_COMPOUND H5T_FACE*D {
            H5T_REAL "areaFrac";
            H5T_REALVECT "centroid";
            H5T_UINT "hiVol"; // used to index into an H5T_VOF*D array
            H5T_UINT "loVol"; // any face only connects two VOFs
 }
 
\end{verbatim}

Header information (as HDF5 {\tt Scalar ATTRIBUTE} unless otherwise specified ):
    \begin{itemize}
    \item {\tt "SpaceDim" \{ DATATYPE  H5T\_INTEGER \}}
    \item {\tt "Filetype" \{ DATATYPE  H5T\_STRING \}}
    \item {\tt "AspectRatio" \{  H5T\_REALVECT \} }
    \item {\tt "NumLevels" \{ H5T\_INTEGER} : number of AMR data AND LevelSet levels
    \item {\tt DATASET "RefRatios" \{ DATATYPE  H5T\_INTEGER \}}
    \item {\tt "ProblemDomain" \{ DATATYPE H5T\_BOX\} } coarsest grid index space
    \item {\tt "DX" \{ DATATYPE  H5T\_REAL \}}
         \begin{itemize} \item  coarse grid spacing \end{itemize}
    \item {\tt ATTRIBUTE  "Ghost" \{ DATATYPE H5T\_INTVECT \}}
    \begin{itemize}
        \item not positive how to handle ghosting actually.  do we allow the face and node centered
            data to have a different amount of ghost cells ?  What would the LevelSet and Mask
            need to look like in this case ?
            Currently this is not going to be allowed. All data sets in an EBData file have the same
           amount of ghost cells.
        \item Box + Ghost are used to determine the sizei, sizej and sizek values. 
                sizei=box.len(0)+2*ghost[0].
    \end{itemize}
 

    \item {\tt "CellCenteredComponents" \{ GROUP\}}
        \begin{itemize} 
            \item  {\tt "NumC" \{ DATATYPE  H5T\_INTEGER \}}
            \item {\tt "ComponentN"  \{ DATATYPE  H5T\_STRING \}} n'th 
                cell-centered  component name
        \end{itemize}
    \item {\tt "XFaceCenteredComponents" \{ GROUP \}}
        \begin{itemize}
            \item  {\tt "NumX" \{ DATATYPE  H5T\_INTEGER \}}
            \item {\tt "ComponentN"  \{ DATATYPE  H5T\_STRING \}} n'th 
                xface-centered  component name
        \end{itemize}
    \item {\tt "YFaceCenteredComponents" \{ GROUP \}}
        \begin{itemize} 
           \item  {\tt "NumY" \{ DATATYPE  H5T\_INTEGER \}}
          \item {\tt "ComponentN"  \{ DATATYPE  H5T\_STRING \}} n'th 
                yface-centered  component name
        \end{itemize}
    \item {\tt "ZFaceCenteredComponents" \{ GROUP \}}
        \begin{itemize} 
                \item  {\tt "NumZ" \{ DATATYPE  H5T\_INTEGER \}}
                \item {\tt "ComponentN"  \{ DATATYPE  H5T\_STRING \}} n'th 
                zface-centered  component name
        \end{itemize}
    \item {\tt "NodeCenteredComponents"  \{ GROUP \}}
        \begin{itemize} 
               \item  {\tt "NumN" \{ DATATYPE  H5T\_INTEGER \}}
                \item {\tt "ComponentN"  \{ DATATYPE  H5T\_STRING \}} n'th 
                node-centered  component name
        \end{itemize}
  \end{itemize}

for each AMR level there is an HDF5 GROUP named {\tt level\_n}.  For each AMR Box at this
level of refinement we have regular data, and a set of irregular data.  The naming convention
has moved to uppercase-contiguous naming instead of lowercase-underscore naming
\begin{itemize}

\item {\tt DATASET "Boxes" \{ DATATYPE  H5T\_BOX \}}
    \begin{itemize} \item  Same meaning as in regular Chombo IO. \end{itemize}
\item {\tt DATASET "Processor" \{ DATATYPE  H5T\_INTEGER \}}
      \begin{itemize} \item Processor assignment of "Boxes" at the time of writing this file \end{itemize}


\item {\tt DATASET "Mask" \{ DATATYPE  H5T\_CHAR \} }
    \begin{itemize}\item  Dataset defined at every point of "Boxes" same as Chombo regular data
                   \item  contains the number volumes in this grid cell.
                   \item not sure if "mask" should be combined with the LevelSet material. 
                    the mask is cell-centered, whereas the LevelSet information is node-centered.
                   \item set to -1 for cells outside problem domain
     \end{itemize}
\item  {\tt DATASET "MOffsets" \{ DATATYPE  H5T\_LLONG \} }

\item {\tt DATASET "Levelset" \{ DATATYPE  H5T\_REAL \} }
          \begin{itemize}
            \item node-centered real-valued data set defined over  "Boxes" 
            \item function is negative valued on covered nodes, positive on uncovered nodes.
            \item I do not know yet if this will be an actual {\em distance function}.
            \item {\em currently unimplemented }
          \end{itemize}

\item  {\tt DATASET "COffsets" \{ DATATYPE  H5T\_LLONG \} }
\item  {\tt DATASET "CRegular" \{ DATATYPE  H5T\_REAL \} } 
    \begin{itemize} 
        \item Regular cell-centered data over  "Boxes"
        \item Indexing the n'th component at position [i,j,k] in the b'th box:
        \item val = CRegular[COffsets[b]+n*(sizei*sizej*sizek)+k*(sizej*sizei)+j*sizei+i]
    \end{itemize}
\item  {\tt DATASET "NOffsets" \{ DATATYPE  H5T\_LLONG \} }
\item  {\tt DATASET "NRegular" \{ DATATYPE  H5T\_REAL \} } 
    \begin{itemize} 
        \item Regular node-centered data over  "Boxes"
        \item Indexing the n'th component at node [i,j,k] in the b'th box:
        \item val = NRegular[NOffsets[b]+n*((sizei+1)*(sizej+1)*(sizek+1))
                            +k*((sizej+1)*(sizei+1))+j*(sizei+1)+i]
    \end{itemize}
\item {\tt DATASET  "VOffsets" \{ DATATYPE  H5T\_UINT \} }
   \begin{itemize} \item  Offset into  {\tt DATASET  "VOFs"} and {\tt DATASET  "CIrregular"} 
                          per box 
    \end{itemize}

\item {\tt DATASET  "VOFs" \{ DATATYPE  H5T\_VOF*D \} }
    \begin{itemize} \item All VOFs stored in box-contiguous form
                    \item This dataset always has a single layer of ghost cells.
    \end{itemize}
\item {\tt DATASET  "CIrregular" \{ DATATYPE  H5T\_REAL \} }
    \begin{itemize} \item contains {\tt NumC} data values per irregular VOF
                    \item indexing the i'th component of the j'th irregular VOF of the b'th Box
                    \item val = irregular[NumC*(VOffsets[b]+j) + i] 
    \end{itemize}

\item  {\tt DATASET "FOffsets" \{ DATATYPE  H5T\_LLONG \} }
\item  {\tt DATASET "XRegular" \{ DATATYPE  H5T\_REAL \} } 
    \begin{itemize} 
        \item Regular x-face centered data over  "Boxes"
        \item Indexing the n'th component at face [i,j,k] in the b'th box:
        \item val = XRegular[FOffsets[b]+n*((sizei+1)*sizej*sizek)+k*((sizej)*
                    (size1+1))+j*(sizei+1)+i]
    \end{itemize}

\item  {\tt DATASET  "XFaceOffsets" \{ DATATYPE  H5T\_UINT \}}
   \begin{itemize} \item  Offset into  {\tt DATASET  "XFaces"  and "XIrregular" }
   \end{itemize}

\item    {\tt DATASET  "XFaces" \{ DATATYPE  H5T\_FACE*D \} }
    \begin{itemize} \item "hiVol" and "loVol" are local to this box. To index 
                           the n'th component of "hiVol"
                           associated with i'th xface of the b'th box:
                    \item val =  CIrregular[NumC*(VOffsets[b] 
                    + (XFaceOffsets[b] + i).hiVol) + n]
     \end{itemize}
\item {\tt DATASET  "XIrregular" \{ DATATYPE  H5T\_REAL \} }
    \begin{itemize}
                 \item to access the n'th data component associated with the i'th
                        xface of the b'th box
                 \item val = XIrregular[(XFaceOffsets[b]+i)*NumX + n]
 
   \end{itemize}   

\item repeat {\tt DATASET}s {\tt "XRegular" "XFaceOffsets" "XFaces" "XIrregular"} for Y and Z faces
   \begin{itemize}
                 \item indexing requires the extra {\tt +1} for the direction in question
   \end{itemize}

\end{itemize}

\subsection{I/O API}


